import os
import time
import pandas as pd
import matplotlib.pyplot as plt
from utils import select_features
from typing import *


class Generator:
    """
        A class used to generate data based on some underlying functions.
        All data is generated into a directory 'sample/data/data_dump_{name or hash value of the class}'.
        The data is saved as a pandas table, along the data some figures are stored to represent the coverage over
        the first two features of the treatment effect.
        ...

        Attributes
        ----------
        main_effect : Callable[[List[float]], float]
            a lambda function defining the effect of features X on outcome Y
        treatment_effect : Callable[[List[float]], float]
            a lambda function defining the effect of treatment W on outcome Y
        treatment_propensity : Callable[[List[float]], float]
            a lambda function defining the effect of features X on treatment W
        noise : Callable[[], float]
            a lambda function defining the noise distribution
        cate : Callable[[List[float]], float]
            a lambda function defining the conditional averaged treatment effect (CATE) of a subpopulation defined
            by a feature vector. To compute only averaged treatment effect (ATE) keep the return value constant.
        treatment_function : Callable[[float, float], float]
            a lambda function defining how it is determined whether treatment is given or not. The inputs should be
            propensity and noise. Usually the function should be Ber(propensity) but it can be changed
        outcome_function : Callable[[float, float, float, float], float]
            a lambda function defining how the outcome is computed. The inputs are the results of
            main_effect, treatment, treatment_effect, noise
        dimensions: int
            integer representing the number of features to be generated
        distributions: List[Callable[[], float]]
            list of functions that determine the values of features. If only one function is given it will be used
            for all features, if multiple are used they need to be defined for every feature.
        directory: str
            directory where all these data dumps are stored. By default is set to 'sample/data'
        generated_files: Dict[str, List[str]]
            dictionary of files and graphs generated by this class

        Methods
        -------
        generate_data(number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False)
            generates a table with data based on input functions of the class
        generate_row()
            generates one row of the data table
        generate_feature(index):
            generates the value for a feature based on self.distributions
        create_graphs(df):
            generates all graphs based on the input dataframe
        create_coverage_graph(df):
            generates a coverage graph based on the input dataframe
        save_graphs():
            saves all generated graphs as figures
        save_data(df):
            saves the dataframe as a csv file
        """

    def __init__(self, main_effect: Callable[[List[float]], float],
                 treatment_effect: Callable[[List[float]], float],
                 treatment_propensity: Callable[[List[float]], float],
                 noise: Callable[[], float],
                 cate: Callable[[List[float]], float],
                 treatment_function: Callable[[float, float], float],
                 outcome_function: Callable[[float, float, float, float], float],
                 dimensions: int, distributions: List[Callable[[], float]], name: str = None):
        """
        Parameters
        ----------
        main_effect : Callable[[List[float]], float]
            a lambda function defining the effect of features X on outcome Y
        treatment_effect : Callable[[List[float]], float]
            a lambda function defining the effect of treatment W on outcome Y
        treatment_propensity : Callable[[List[float]], float]
            a lambda function defining the effect of features X on treatment W
        noise : Callable[[], float]
            a lambda function defining the noise distribution
        cate : Callable[[List[float]], float]
            a lambda function defining the conditional averaged treatment effect (CATE) of a subpopulation defined
            by a feature vector. To compute only averaged treatment effect (ATE) keep the return value constant.
        treatment_function : Callable[[float, float], float]
            a lambda function defining how it is determined whether treatment is given or not. The inputs should be
            propensity and noise. Usually the function should be Ber(propensity) but it can be changed
        outcome_function : Callable[[float, float, float, float], float]
            a lambda function defining how the outcome is computed. The inputs are the results of
            main_effect, treatment, treatment_effect, noise
        dimensions: int
            integer representing the number of features to be generated
        distributions: List[Callable[[], float]]
            list of functions that determine the values of features. If only one function is given it will be used
            for all features, if multiple are used they need to be defined for every feature
        name: str
            name of the data dump. This will be used to create the directory of the data dump
        """
        # Either have 1 distribution applied on all features, or have a specific distribution per feature
        assert len(distributions) == 1 or len(distributions) == dimensions
        if name is None:
            name = self.__hash__()
        self.main_effect = main_effect
        self.treatment_effect = treatment_effect
        self.treatment_propensity = treatment_propensity
        self.treatment_function = treatment_function
        self.outcome_function = outcome_function
        self.noise = noise
        self.cate = cate
        self.dimensions = dimensions
        self.distributions = distributions
        self.directory: str = f'data/data_dump_{name}'
        self.generated_files: Dict[str, List[str]] = {'data': [], 'graphs': []}

    def generate_data(self, number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False):
        """
        Parameters
        ----------
        number_of_samples : int
            indicates the number of rows to be generated
        save_data: bool
            indicates whether the generated data should be stored
        show_graphs: bool
            indicates whether the generated graphs should also be shown WIP
        save_graphs: bool
            indicates whether the generated graphs should be stored
        """
        columns = [f'feature_{i}' for i in range(self.dimensions)]
        columns.append('treatment')
        columns.append('outcome')
        columns.append('main_effect')
        columns.append('treatment_effect')
        columns.append('propensity')
        columns.append('y0')
        columns.append('y1')
        columns.append('noise')
        columns.append('cate')
        df = pd.DataFrame([], columns=columns)
        for i in range(number_of_samples):
            features, treatment, outcome, main_effect, treatment_effect, propensity, y0, y1, noise, cate = self.generate_row()
            features.append(treatment)
            features.append(outcome)
            features.append(main_effect)
            features.append(treatment_effect)
            features.append(propensity)
            features.append(y0)
            features.append(y1)
            features.append(noise)
            features.append(cate)
            df.loc[len(df.index)] = features
        if save_data:
            self.save_data(df)
        if show_graphs or save_graphs:
            self.create_graphs(df)
            if save_graphs:
                self.save_graphs()
            if show_graphs:
                plt.show()
        return select_features(df, self.dimensions), df['treatment'], df['outcome'], df['main_effect'], \
               df['treatment_effect'], df['propensity'], df['y0'], df['y1'], df['noise'], df['cate']

    def generate_row(self):
        features = []
        for dimension in range(self.dimensions):
            features.append(self.generate_feature(dimension))
        # propensity = p(T = 1 | X)
        propensity = self.treatment_propensity(features)
        treatment_noise = self.noise()
        treatment = self.treatment_function(propensity, treatment_noise)
        treatment_effect = self.treatment_effect(features)
        main_effect = self.main_effect(features)
        noise = self.noise()
        outcome = self.outcome_function(main_effect, treatment, treatment_effect, noise)
        y0 = self.outcome_function(main_effect, 0, treatment_effect, 0)
        y1 = self.outcome_function(main_effect, 1, treatment_effect, 0)
        # Cate : E[Y1 - Y0|X]
        cate = self.cate(features)
        # True treatment effect is y1 - y0 where there is no noise
        return features, treatment, outcome, main_effect, y1 - y0, propensity, y0, y1, noise, cate

    def generate_feature(self, index):
        """
        Parameters
        ----------
        index : int
            represent the index from which distribution should the feature take its value from.
            If only one distribution is provided all features will take from that distribution.
        """
        if len(self.distributions) == 1:
            return self.distributions[0]()
        return self.distributions[index]()

    def create_graphs(self, df):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        self.create_coverage_graph(df)

    def create_coverage_graph(self, df):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        plt.clf()
        feature_one = df['feature_0']
        feature_two = df['feature_1']
        maximal = df['treatment_effect'].max()
        minimal = df['treatment_effect'].min()
        color_function = lambda i: [0,
                                    min(1,
                                        (df.iloc[i]['treatment_effect'] - minimal) / (maximal - minimal + 0.01)),
                                    1 - (df.iloc[i]['treatment_effect'] - minimal) / (maximal - minimal + 0.01)]
        plt.scatter(feature_one, feature_two, c=[color_function(i) for i in df.index])

    def save_graphs(self):
        os.makedirs(self.directory, exist_ok=True)
        filename = f'/coverage_{time.ctime()}'.replace(' ', '_').replace(':', '-')
        self.generated_files['graphs'].append(filename)
        plt.savefig(self.directory + filename)

    def save_data(self, df):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        os.makedirs(self.directory, exist_ok=True)
        filename = f'/generated_data{time.ctime()}.csv'.replace(' ', '_').replace(':', '-')
        self.generated_files['data'].append(filename)
        df.to_csv(self.directory + filename)
